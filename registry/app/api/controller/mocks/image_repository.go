// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	artifact "github.com/harness/gitness/registry/app/api/openapi/contracts/artifact"

	mock "github.com/stretchr/testify/mock"

	types "github.com/harness/gitness/registry/types"
)

// ImageRepository is an autogenerated mock type for the ImageRepository type
type ImageRepository struct {
	mock.Mock
}

// CountLabelsByParentIDAndRepo provides a mock function with given fields: ctx, parentID, repo, search, softDeleteFilter
func (_m *ImageRepository) CountLabelsByParentIDAndRepo(ctx context.Context, parentID int64, repo string, search string, softDeleteFilter types.SoftDeleteFilter) (int64, error) {
	ret := _m.Called(ctx, parentID, repo, search, softDeleteFilter)

	if len(ret) == 0 {
		panic("no return value specified for CountLabelsByParentIDAndRepo")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, string, types.SoftDeleteFilter) (int64, error)); ok {
		return rf(ctx, parentID, repo, search, softDeleteFilter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, string, types.SoftDeleteFilter) int64); ok {
		r0 = rf(ctx, parentID, repo, search, softDeleteFilter)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, string, string, types.SoftDeleteFilter) error); ok {
		r1 = rf(ctx, parentID, repo, search, softDeleteFilter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateOrUpdate provides a mock function with given fields: ctx, image
func (_m *ImageRepository) CreateOrUpdate(ctx context.Context, image *types.Image) error {
	ret := _m.Called(ctx, image)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Image) error); ok {
		r0 = rf(ctx, image)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteByImageNameAndRegID provides a mock function with given fields: ctx, regID, image
func (_m *ImageRepository) DeleteByImageNameAndRegID(ctx context.Context, regID int64, image string) error {
	ret := _m.Called(ctx, regID, image)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByImageNameAndRegID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string) error); ok {
		r0 = rf(ctx, regID, image)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteByImageNameIfNoLinkedArtifacts provides a mock function with given fields: ctx, regID, image
func (_m *ImageRepository) DeleteByImageNameIfNoLinkedArtifacts(ctx context.Context, regID int64, image string) error {
	ret := _m.Called(ctx, regID, image)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByImageNameIfNoLinkedArtifacts")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string) error); ok {
		r0 = rf(ctx, regID, image)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DuplicateImage provides a mock function with given fields: ctx, sourceImage, targetRegistryID
func (_m *ImageRepository) DuplicateImage(ctx context.Context, sourceImage *types.Image, targetRegistryID int64) (*types.Image, error) {
	ret := _m.Called(ctx, sourceImage, targetRegistryID)

	if len(ret) == 0 {
		panic("no return value specified for DuplicateImage")
	}

	var r0 *types.Image
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Image, int64) (*types.Image, error)); ok {
		return rf(ctx, sourceImage, targetRegistryID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.Image, int64) *types.Image); ok {
		r0 = rf(ctx, sourceImage, targetRegistryID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Image)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.Image, int64) error); ok {
		r1 = rf(ctx, sourceImage, targetRegistryID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Get provides a mock function with given fields: ctx, id, softDeleteFilter
func (_m *ImageRepository) Get(ctx context.Context, id int64, softDeleteFilter types.SoftDeleteFilter) (*types.Image, error) {
	ret := _m.Called(ctx, id, softDeleteFilter)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *types.Image
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, types.SoftDeleteFilter) (*types.Image, error)); ok {
		return rf(ctx, id, softDeleteFilter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, types.SoftDeleteFilter) *types.Image); ok {
		r0 = rf(ctx, id, softDeleteFilter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Image)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, types.SoftDeleteFilter) error); ok {
		r1 = rf(ctx, id, softDeleteFilter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByName provides a mock function with given fields: ctx, registryID, name, includeSoftDeleted
func (_m *ImageRepository) GetByName(ctx context.Context, registryID int64, name string, includeSoftDeleted types.SoftDeleteFilter) (*types.Image, error) {
	ret := _m.Called(ctx, registryID, name, includeSoftDeleted)

	if len(ret) == 0 {
		panic("no return value specified for GetByName")
	}

	var r0 *types.Image
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, types.SoftDeleteFilter) (*types.Image, error)); ok {
		return rf(ctx, registryID, name, includeSoftDeleted)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, types.SoftDeleteFilter) *types.Image); ok {
		r0 = rf(ctx, registryID, name, includeSoftDeleted)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Image)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, string, types.SoftDeleteFilter) error); ok {
		r1 = rf(ctx, registryID, name, includeSoftDeleted)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByNameAndType provides a mock function with given fields: ctx, registryID, name, artifactType, includeSoftDeleted
func (_m *ImageRepository) GetByNameAndType(ctx context.Context, registryID int64, name string, artifactType *artifact.ArtifactType, includeSoftDeleted types.SoftDeleteFilter) (*types.Image, error) {
	ret := _m.Called(ctx, registryID, name, artifactType, includeSoftDeleted)

	if len(ret) == 0 {
		panic("no return value specified for GetByNameAndType")
	}

	var r0 *types.Image
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, *artifact.ArtifactType, types.SoftDeleteFilter) (*types.Image, error)); ok {
		return rf(ctx, registryID, name, artifactType, includeSoftDeleted)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, *artifact.ArtifactType, types.SoftDeleteFilter) *types.Image); ok {
		r0 = rf(ctx, registryID, name, artifactType, includeSoftDeleted)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Image)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, string, *artifact.ArtifactType, types.SoftDeleteFilter) error); ok {
		r1 = rf(ctx, registryID, name, artifactType, includeSoftDeleted)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByRepoAndName provides a mock function with given fields: ctx, parentID, repo, name, softDeleteFilter
func (_m *ImageRepository) GetByRepoAndName(ctx context.Context, parentID int64, repo string, name string, softDeleteFilter types.SoftDeleteFilter) (*types.Image, error) {
	ret := _m.Called(ctx, parentID, repo, name, softDeleteFilter)

	if len(ret) == 0 {
		panic("no return value specified for GetByRepoAndName")
	}

	var r0 *types.Image
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, string, types.SoftDeleteFilter) (*types.Image, error)); ok {
		return rf(ctx, parentID, repo, name, softDeleteFilter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, string, types.SoftDeleteFilter) *types.Image); ok {
		r0 = rf(ctx, parentID, repo, name, softDeleteFilter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Image)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, string, string, types.SoftDeleteFilter) error); ok {
		r1 = rf(ctx, parentID, repo, name, softDeleteFilter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLabelsByParentIDAndRepo provides a mock function with given fields: ctx, parentID, repo, limit, offset, search, softDeleteFilter
func (_m *ImageRepository) GetLabelsByParentIDAndRepo(ctx context.Context, parentID int64, repo string, limit int, offset int, search string, softDeleteFilter types.SoftDeleteFilter) ([]string, error) {
	ret := _m.Called(ctx, parentID, repo, limit, offset, search, softDeleteFilter)

	if len(ret) == 0 {
		panic("no return value specified for GetLabelsByParentIDAndRepo")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, int, int, string, types.SoftDeleteFilter) ([]string, error)); ok {
		return rf(ctx, parentID, repo, limit, offset, search, softDeleteFilter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, int, int, string, types.SoftDeleteFilter) []string); ok {
		r0 = rf(ctx, parentID, repo, limit, offset, search, softDeleteFilter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, string, int, int, string, types.SoftDeleteFilter) error); ok {
		r1 = rf(ctx, parentID, repo, limit, offset, search, softDeleteFilter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Purge provides a mock function with given fields: ctx, accountID, deletedBeforeOrAt
func (_m *ImageRepository) Purge(ctx context.Context, accountID string, deletedBeforeOrAt int64) (int64, error) {
	ret := _m.Called(ctx, accountID, deletedBeforeOrAt)

	if len(ret) == 0 {
		panic("no return value specified for Purge")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) (int64, error)); ok {
		return rf(ctx, accountID, deletedBeforeOrAt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) int64); ok {
		r0 = rf(ctx, accountID, deletedBeforeOrAt)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int64) error); ok {
		r1 = rf(ctx, accountID, deletedBeforeOrAt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreByImageNameAndRegID provides a mock function with given fields: ctx, regID, image
func (_m *ImageRepository) RestoreByImageNameAndRegID(ctx context.Context, regID int64, image string) error {
	ret := _m.Called(ctx, regID, image)

	if len(ret) == 0 {
		panic("no return value specified for RestoreByImageNameAndRegID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string) error); ok {
		r0 = rf(ctx, regID, image)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SoftDeleteByImageNameAndRegID provides a mock function with given fields: ctx, regID, image
func (_m *ImageRepository) SoftDeleteByImageNameAndRegID(ctx context.Context, regID int64, image string) error {
	ret := _m.Called(ctx, regID, image)

	if len(ret) == 0 {
		panic("no return value specified for SoftDeleteByImageNameAndRegID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string) error); ok {
		r0 = rf(ctx, regID, image)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Update provides a mock function with given fields: ctx, _a1
func (_m *ImageRepository) Update(ctx context.Context, _a1 *types.Image) error {
	ret := _m.Called(ctx, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Image) error); ok {
		r0 = rf(ctx, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateStatus provides a mock function with given fields: ctx, _a1
func (_m *ImageRepository) UpdateStatus(ctx context.Context, _a1 *types.Image) error {
	ret := _m.Called(ctx, _a1)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Image) error); ok {
		r0 = rf(ctx, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewImageRepository creates a new instance of ImageRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewImageRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *ImageRepository {
	mock := &ImageRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
